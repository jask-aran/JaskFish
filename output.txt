Project Path: /home/jask/JaskFish/src

Source Tree:

```
src
├── utils.py
├── gui.py
├── main.py
├── engine.py
└── chess_logic.py

```

`/home/jask/JaskFish/src/utils.py`:

```````py
from PySide2.QtWidgets import QApplication
def color_text(text, color_code):
    return f"\033[{color_code}m{text}\033[0m"

def debug_text(text):
    return f"{color_text('DEBUG', '31')} {text}"

def info_text(text):
    return f"{color_text('INFO', '34')}  {text}"

def sending_text(text):
    return f"{color_text('SENDING  ', '32')} {text}"

def recieved_text(text):
    return f"{color_text('RECIEVED ', '35')} {text}"

def cleanup(process, thread, app, dev=False):
    if dev:
        print(debug_text("Cleaning up resources..."))
    
    # Safely terminate the process
    if process is not None:
        process.terminate()  # Send termination signal
        process.waitForFinished()  # Wait for the process to exit

    # Only join the thread if it exists
    if thread is not None:
        thread.join()
    
    app.quit()

def get_piece_unicode(piece):
    piece_unicode = {
        'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    }
    return piece_unicode[piece.symbol()]

def center_on_screen(window):
    screen = QApplication.primaryScreen()
    screen_geometry = screen.geometry()
    window_size = window.size()
    x = (screen_geometry.width() - window_size.width()) / 2 + screen_geometry.left()
    y = (screen_geometry.height() - window_size.height()) / 2 + screen_geometry.top()
    window.move(x, y)
```````

`/home/jask/JaskFish/src/gui.py`:

```````py
# GUI
import sys
import chess
import json
import time
import os
from PySide2.QtCore import Qt, QSize
from PySide2.QtGui import QFont
from PySide2.QtWidgets import QApplication, QMainWindow, QWidget, QGridLayout, QPushButton, QLabel, QVBoxLayout, QMessageBox, QHBoxLayout, QDialog, QComboBox

import chess_logic
import utils

class PromotionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Pawn Promotion")
        layout = QVBoxLayout()
        self.setLayout(layout)

        self.combo = QComboBox()
        self.combo.addItems(["Queen", "Rook", "Bishop", "Knight"])
        layout.addWidget(self.combo)

        button = QPushButton("OK")
        button.clicked.connect(self.accept)
        layout.addWidget(button)

    def get_promotion_piece(self):
        return self.combo.currentText().lower()
    

class ChessGUI(QMainWindow):
    def __init__(self, board, dev=False, go_callback=None, ready_callback=None, restart_engine_callback=None):
        super().__init__()
        self.board = board
        self.initial_fen = self.board.fen()
        self.selected_square = None
        self.dev = dev
        self.player_is_white = self.get_player_color()
        self.board.turn = chess.WHITE if self.player_is_white else chess.BLACK
        self.go_callback = go_callback
        self.ready_callback = ready_callback
        self.restart_engine_callback = restart_engine_callback
        print(utils.info_text("Starting Game..."))
        
        # Reporting Options
        self.full_reporting = True
        if self.dev:
            print(utils.debug_text("Debug Mode ENABLED"))
            print(utils.debug_text(f"Full Reporting {'ENABLED' if self.full_reporting else 'DISABLED'}"))
            print(utils.debug_text(f"User Color {'WHITE' if self.player_is_white else 'BLACK'}")) 
        self.init_ui()

    def get_player_color(self):
        if self.dev:
            return True # Always play as white in dev mode
        
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Choose Your Color")
        white_button = msg_box.addButton("White", QMessageBox.YesRole)
        black_button = msg_box.addButton("Black", QMessageBox.NoRole)
        utils.center_on_screen(msg_box)
        msg_box.exec_()

        return msg_box.clickedButton() == white_button
    
    def init_ui(self):
        self.setWindowTitle('JaskFish')
        self.setGeometry(100, 100, 500, 550)

        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        self.turn_indicator = QLabel("White's turn" if self.board.turn == chess.WHITE else "Black's turn")
        self.turn_indicator.setAlignment(Qt.AlignCenter)
        self.turn_indicator.setFont(QFont('Arial', 16))
        main_layout.addWidget(self.turn_indicator)
        
        self.info_indicator = QLabel("Game Started")
        self.info_indicator.setAlignment(Qt.AlignCenter)
        self.info_indicator.setFont(QFont('Arial', 10))
        main_layout.addWidget(self.info_indicator)

        board_widget = QWidget()
        grid_layout = QGridLayout(board_widget)
        main_layout.addWidget(board_widget)

        label_font = QFont('Arial', 14)
        files = 'abcdefgh'

        # Add file and rank labels
        for i in range(8):
            file_label = QLabel(files[i], alignment=Qt.AlignCenter, font=label_font)
            rank_label = QLabel(str(8 - i), alignment=Qt.AlignCenter, font=label_font)
            grid_layout.addWidget(file_label, 8, i + 1)
            grid_layout.addWidget(rank_label, i, 0)

        # Create board squares
        self.squares = {}
        for row in range(8):
            for col in range(8):
                button = QPushButton(fixedSize=QSize(50, 50), font=QFont('Arial', 20))
                button.clicked.connect(self.on_square_clicked)
                grid_layout.addWidget(button, row, col + 1)
                self.squares[chess.square(col, 7 - row)] = button

        button_layout = QHBoxLayout()
        main_layout.addLayout(button_layout)
        
        undo_button = QPushButton("Undo")
        undo_button.clicked.connect(self.undo_move)
        button_layout.addWidget(undo_button)
        
        export_button = QPushButton("Export")
        export_button.clicked.connect(self.export_game)
        button_layout.addWidget(export_button)

        reset_button = QPushButton("Reset board")
        reset_button.clicked.connect(self.reset_game)
        button_layout.addWidget(reset_button)
        
        button_layout2 = QHBoxLayout()
        main_layout.addLayout(button_layout2)
        
        ready_button = QPushButton("Ready")
        ready_button.clicked.connect(self.ready_command)
        button_layout2.addWidget(ready_button)
        
        go_button = QPushButton("Go")
        go_button.clicked.connect(self.go_command)
        button_layout2.addWidget(go_button)
        
        restart_engine_button = QPushButton("Restart Engine")
        restart_engine_button.clicked.connect(self.restart_engine)
        button_layout2.addWidget(restart_engine_button)

        self.update_board()
        utils.center_on_screen(self)

    def update_board(self, info_text=None):
        last_move = None
        if self.board.move_stack:
            last_move_move = self.board.move_stack[-1]
            last_move = [chess.square_name(last_move_move.from_square), chess.square_name(last_move_move.to_square)]
        
        for square, button in self.squares.items():
            piece = self.board.piece_at(square)
            button.setText(utils.get_piece_unicode(piece) if piece else '')
            button.setStyleSheet(self.get_square_style(square, last_moved=last_move))
    
        self.turn_indicator.setText("White's turn" if self.board.turn == chess.WHITE else "Black's turn")
        self.info_indicator.setText(info_text) if info_text else None

        if chess_logic.is_game_over(self.board):
            outcome = chess_logic.get_game_result(self.board)
            print(utils.info_text(f"Game Over: {outcome}"))
            QMessageBox.information(self, "Game Over", outcome)

    def get_square_style(self, square, last_moved=None):
        square_style = {
            'light_square': "#F0D9B5",
            'dark_square': "#B58863",
            'selected_color': "#646F40",
            'prev_moved_color': "#ddf0a1",
            'attacked_color': "#fca5a5"
        }

        is_light = (chess.square_rank(square) + chess.square_file(square)) % 2 == 1
        square_color = square_style['light_square'] if is_light else square_style['dark_square']
        piece = self.board.piece_at(square)
        
        if square == self.selected_square:
            square_color = square_style['selected_color']
        elif piece and piece.piece_type == chess.KING and self.board.is_attacked_by(not piece.color, square):
            square_color = square_style['attacked_color']
            print(utils.info_text(f"{chess.square_name(square)} In Check ({'White' if piece.color else 'Black'})"))
        elif last_moved and square in [chess.parse_square(sq) for sq in last_moved]:
            square_color = square_style['prev_moved_color']
        
        return f"background-color: {square_color};"
        
    def on_square_clicked(self):
        clicked_button = self.sender()
        clicked_square = next(square for square, button in self.squares.items() if button == clicked_button)

        def is_own_color(square):
            piece = self.board.piece_at(square)
            return piece and piece.color == self.board.turn

        if self.selected_square == clicked_square: # Handle unselecting
            self.selected_square = None
            print(utils.debug_text(f"{chess.square_name(clicked_square)} Unselected")) if self.dev and self.full_reporting else None
        elif is_own_color(clicked_square): # Handle selecting/ reselecting own piece
            self.selected_square = clicked_square
            print(utils.debug_text(f"{chess.square_name(clicked_square)} Selected")) if self.dev and self.full_reporting else None
        elif self.selected_square is not None: # Handle move attempt
            move = chess.Move(self.selected_square, clicked_square)
            self.attempt_move(move)
            self.selected_square = None
        else:
            print(utils.debug_text("No Piece on Square/ Wrong color")) if self.dev and self.full_reporting else None
            
        self.update_board()
        
    
    def attempt_move(self, move):
        # Move in form e1e2
        print(utils.debug_text(f"Move attempted: {chess.square_name(move.from_square)} -> {chess.square_name(move.to_square)}")) \
            if self.dev and self.full_reporting else None

        if chess_logic.is_pawn_promotion_attempt(self.board, move):
            promotion_choice = self.get_promotion_choice()
            if not promotion_choice:
                return
            move.promotion = promotion_choice

        if chess_logic.is_valid_move(self.board, move):
            print(utils.info_text(f"{str(move)} {utils.color_text('Valid Move', '32')} by {'White' if self.board.turn else 'Black'}"))
            chess_logic.make_move(self.board, move)
            self.selected_square = None
        else:
            print(utils.info_text(f"{str(move)} {utils.color_text('Invalid Move', '31')} attempted by {'White' if self.board.turn else 'Black'}"))
        
    def attempt_engine_move(self, move_uci):
        move = chess.Move.from_uci(move_uci)
        print(utils.info_text(f"Engine Move Attempted: {chess.square_name(move.from_square)} -> {chess.square_name(move.to_square)}"))
        self.attempt_move(move)
        self.update_board()
        
    def get_promotion_choice(self):
        dialog = PromotionDialog(self)
        if dialog.exec_():
            piece = dialog.get_promotion_piece()
            return {'queen': chess.QUEEN, 'rook': chess.ROOK, 'bishop': chess.BISHOP, 'knight': chess.KNIGHT}[piece]
        
        print(utils.debug_text("Promotion Dialog Cancelled"))
        return None  # Return None if the dialog is cancelled

    def reset_game(self):
        print(utils.info_text("Resetting game..."))
        self.board.reset()
        self.initial_fen = self.board.fen()
        self.selected_square = None
        self.update_board(info_text="Game Reset")
        
    def undo_move(self):
        last_move = self.board.peek() if self.board.move_stack else None
        if last_move:
            chess_logic.undo_move(self.board)
            
        if last_move and self.dev:
            print(utils.debug_text(f"{last_move} Undone"))
            last_move = None
        elif self.dev:
            print(utils.debug_text("Move Stack Empty"))
        
        self.selected_square = None
        self.update_board()
        
    def game_state(self):
        return self.board.fen()
    
    def export_game(self):
        print(utils.info_text("---EXPORTING GAME---"))
        
        game_state = {
            'export-time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())),
            'fen-init': self.initial_fen,
            'fen-final': self.board.fen(),
            'san': chess_logic.export_move_history_san(self.board),
            'uci': chess_logic.export_move_history_uci(self.board)
        }
        
        gamestates_folder = 'gamestates'
        if not os.path.exists(gamestates_folder):
            os.makedirs(gamestates_folder)
            
        if self.dev:
            with open(f'{gamestates_folder}/DEV_game_state.json', 'w') as outfile:
                json.dump(game_state, outfile)
        else:
            with open(f'{gamestates_folder}/chess_game_{game_state["export-time"]}.json', 'w') as outfile:
                json.dump(game_state, outfile)
            
        print(utils.info_text(f"FEN: {game_state['fen-final']}"))
        print(utils.info_text(f"SAN: {game_state['san']}"))
        print(utils.info_text(f"UCI: {game_state['uci']}"))
    
    def go_command(self):
        if self.go_callback:
            self.go_callback(fen_string=self.board.fen())
        else:
            print(utils.debug_text("Go callback not set"))
        
    def ready_command(self):
        if self.ready_callback:
            self.ready_callback()
        else:
            print(utils.debug_text("Ready callback not set"))
            
    def restart_engine(self):
        if self.restart_engine_callback:
            self.restart_engine_callback()
        else:
            print(utils.debug_text("Restart engine callback not set"))
        
    


if __name__ == '__main__':
    app = QApplication(sys.argv)
    # board = chess.Board()
    board = chess.Board("k7/2Q4P/8/8/8/8/8/K2R4")

    chess_gui = ChessGUI(board, dev=True)

    chess_gui.show()
    sys.exit(app.exec_())
```````

`/home/jask/JaskFish/src/main.py`:

```````py
# MAIN
import sys
import chess
import argparse
import os

from PySide2.QtWidgets import QApplication
from PySide2.QtCore import QProcess

from gui import ChessGUI
from utils import cleanup, sending_text, recieved_text, info_text

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-fen', help='Set the initial board state to the given FEN string')
    parser.add_argument('-dev', action='store_true', help='Enable debug mode')
    return parser.parse_args()
    # Example FEN: k7/2Q4P/8/8/8/8/8/K2R4

def send_command(proc, command):
    print(sending_text(command))
    proc.write((command + '\n').encode())
    proc.waitForBytesWritten()

def handle_command_go(proc, fen_string):
    send_command(proc, f"position fen {fen_string}")
    send_command(proc, "go")

def handle_command_readyok(proc):
    send_command(proc, "isready")
    
def handle_bestmove(proc, bestmove, gui):
    print(recieved_text(bestmove))
    parts = bestmove.strip().split()
    if len(parts) >= 2:
        move_uci = parts[1]
        gui.attempt_engine_move(move_uci)
    else:
        print("info string No best move found.")

def engine_output_processor(proc, gui):
    while proc.canReadLine():
        output = bytes(proc.readLine()).decode().strip()
        if output.startswith('bestmove'):
            handle_bestmove(proc, output, gui)
        elif output:
            print(recieved_text(output))
            
def restart_engine(engine_process, gui, engine_path):
    print(info_text("Restarting engine..."))
    if engine_process.state() == QProcess.Running:
        engine_process.kill()
        engine_process.waitForFinished()
    
    engine_process.start("python3", [engine_path])
    send_command(engine_process, 'debug on') if gui.dev else None
    print(info_text("Engine restarted"))

def main():
    args = parse_args()
    board = chess.Board() if not args.fen else chess.Board(args.fen)
    dev = not args.dev
    
    # Find absolute path to engine.py
    script_dir = os.path.dirname(os.path.abspath(__file__))
    engine_path = os.path.join(script_dir, "engine.py")
    
    # Construct GUI object
    app = QApplication(sys.argv)
    go_callback = lambda fen_string: handle_command_go(engine_process, fen_string)
    ready_callback = lambda: handle_command_readyok(engine_process)
    restart_engine_callback = lambda: restart_engine(engine_process, gui, engine_path)
    gui = ChessGUI(board, dev=dev, go_callback=go_callback, ready_callback=ready_callback, restart_engine_callback=restart_engine_callback)
    
    # Start engine
    engine_process = QProcess()
    engine_process.setProcessChannelMode(QProcess.MergedChannels)
    engine_process.readyReadStandardOutput.connect(lambda: engine_output_processor(engine_process, gui))
    engine_process.start("python3", [engine_path])
    
    # Enable debug mode
    send_command(engine_process, 'debug on') if dev else None


    app.aboutToQuit.connect(lambda: cleanup(engine_process, None, app, dev=dev))

    gui.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

```````

`/home/jask/JaskFish/src/engine.py`:

```````py
import sys
import io
import random
import chess
import time
import threading

# Ensure stdout is line-buffered
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, line_buffering=True)


class ChessEngine:
    """
    A simple chess engine that communicates using a custom UCI-like protocol.
    It can process commands to set up positions, calculate moves, and manage engine state.
    """

    def __init__(self):
        """Initialize the chess engine with default settings and state."""
        # Engine identification
        self.engine_name = 'JaskFish'
        self.engine_author = 'Jaskaran Singh'

        # Engine state
        self.board = chess.Board()
        self.debug = False
        self.move_calculating = False
        self.running = True

        # Lock to manage concurrent access to engine state
        self.state_lock = threading.Lock()

        # Dispatch table mapping commands to handler methods
        self.dispatch_table = {
            'quit': self.handle_quit,
            'debug': self.handle_debug,
            'isready': self.handle_isready,
            'position': self.handle_position,
            'boardpos': self.handle_boardpos,
            'go': self.handle_go,
            'ucinewgame': self.handle_ucinewgame,
            'uci': self.handle_uci
        }

    def start(self):
        self.handle_uci()
        self.command_processor()
        
    def handle_uci(self, args=None):
        print(f'id name {self.engine_name}')
        print(f'id author {self.engine_author}')
        print('uciok')

    def command_processor(self):
        """
        Continuously read and process commands from stdin.
        Commands are dispatched to appropriate handler methods based on the dispatch table.
        """
        while self.running:
            try:
                command = sys.stdin.readline()
                if not command:
                    break  # EOF reached
                command = command.strip()
                if not command:
                    continue  # Ignore empty lines

                # Split the command into parts for dispatching
                parts = command.split(' ', 1)
                cmd = parts[0].lower()
                args = parts[1] if len(parts) > 1 else ''

                # Dispatch the command to the appropriate handler
                handler = self.dispatch_table.get(cmd, self.handle_unknown)
                handler(args)
            except Exception as e:
                print(f'info string Error processing command: {e}')
            finally:
                sys.stdout.flush()


    def handle_unknown(self, args):
        print(f"unknown command received: '{args}'")

    def handle_quit(self, args):
        print('info string Engine shutting down')
        self.running = False

    def handle_debug(self, args):
        setting = args.strip().lower()
        if setting == "on":
            self.debug = True
        elif setting == "off":
            self.debug = False
        else:
            print("info string Invalid debug setting. Use 'on' or 'off'.")
            return
        print(f"info string Debug:{self.debug}")

    def handle_isready(self, args):
        with self.state_lock:
            if not self.move_calculating:
                print("readyok")
            else:
                print("info string Engine is busy processing a move")

    def handle_position(self, args):
        with self.state_lock:
            if args.startswith("startpos"):
                self.board.reset()
                if self.debug:
                    print(f"info string Set to start position: {self.board.fen()}")
            elif args.startswith("fen"):
                fen = args[4:].strip()
                try:
                    self.board.set_fen(fen)
                    if self.debug:
                        print(f"info string setpos {self.board.fen()}")
                except ValueError:
                    print("info string Invalid FEN string provided.")
            else:
                print("info string Unknown position command.")

    def handle_boardpos(self, args):
        with self.state_lock:
            print(f"info string Position: {self.board.fen()}" if self.board else "info string Board state not set")

    def handle_go(self, args):
        with self.state_lock:
            if self.move_calculating:
                print('info string Please wait for computer move')
                return
            self.move_calculating = True

        # Start the move calculation in a separate thread
        move_thread = threading.Thread(target=self.process_go_command)
        move_thread.start()

    def handle_ucinewgame(self, args):
        with self.state_lock:
            self.board.reset()
            if self.debug:
                print("info string New game started, board reset to initial position")
            print("info string New game initialized")

    def random_move(self, board):
        legal_moves = list(board.legal_moves)
        if not legal_moves:
            return None
        selected_move = random.choice(legal_moves)
        return selected_move.uci()
        
    def process_go_command(self):
        if self.debug:
            print(f"info string calc start: {self.board.fen()}")

        # Simulate a long move calculation
        time.sleep(2)

        with self.state_lock:
            move = self.random_move(self.board)
            if move:
                print(f"bestmove {move}")
                print("readyok")
            else:
                print("bestmove (none)")
            self.move_calculating = False



engine = ChessEngine()
engine.start()

```````

`/home/jask/JaskFish/src/chess_logic.py`:

```````py
import chess

def is_valid_move(board: chess.Board, move: chess.Move) -> bool:
    return move in board.legal_moves

def is_game_over(board: chess.Board) -> bool:
    return board.is_game_over()

def get_game_result(board: chess.Board) -> str:
    if board.is_checkmate():
        return "Checkmate"
    elif board.is_stalemate():
        return "Stalemate"
    elif board.is_insufficient_material():
        return "Insufficient Material"
    elif board.is_seventyfive_moves():
        return "75-move rule"
    elif board.is_fivefold_repetition():
        return "Fivefold Repetition"
    elif board.is_variant_draw():
        return "Variant-specific Draw"
    else:
        return "Game in progress"

def is_in_check(board: chess.Board) -> bool:
    return board.is_check()

def get_possible_moves(board: chess.Board, square: chess.Square) -> list:
    return [move for move in board.legal_moves if move.from_square == square]

def make_move(board: chess.Board, move: chess.Move) -> None:
    board.push(move)

def undo_move(board: chess.Board) -> None:
    if board.move_stack:
        board.pop()
        return True
    return False

    
def is_pawn_promotion_attempt(board: chess.Board, move: chess.Move) -> bool:
    piece = board.piece_at(move.from_square)
    if piece is None or piece.piece_type != chess.PAWN:
        return False
    
    move.promotion = chess.QUEEN
    if not is_valid_move(board, move):
        move.promotion = None
        return False
    
    rank = chess.square_rank(move.to_square)
    return (piece.color == chess.WHITE and rank == 7) or (piece.color == chess.BLACK and rank == 0)

def export_board_fen(board: chess.Board) -> str:
    return board.fen()


def export_move_history_uci(board: chess.Board) -> str:
    """Exports the move history of a chess game in Universal Chess Interface (UCI) format."""
    moves_uci = [move.uci() for move in board.move_stack]
    return ' '.join(moves_uci)

import chess

def export_move_history_san(board: chess.Board) -> str:
    moves_san = []
    temp_board = board.copy()  # Create a copy of the board
    temp_board.reset()  # Reset to starting position
    
    for move in board.move_stack:
        
        moves_san.append(temp_board.san(move))  # Convert to SAN before applying
        temp_board.push(move)  # Apply the move
    
    return ' '.join(moves_san)


```````